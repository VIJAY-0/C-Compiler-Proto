# Helium Compiler

Helium is a lightweight, basic compiler designed as a personal project to explore and understand the implementation details of compiler architecture. It serves as a study tool for learning the various stages of compilation.

## Features

*   **Lexical Analysis:** Converts source code into a stream of tokens.
*   **Syntax Analysis:** Parses the token stream to build an Abstract Syntax Tree (AST) based on a defined grammar.
*   **Symbol Table Management:** Keeps track of identifiers and their attributes.
*   **Intermediate Code Generation:** (Potentially) Generates an intermediate representation of the code.
*   **Basic Code Generation:** (Potentially) Generates target code (e.g., assembly or another high-level language) from the intermediate representation or AST.

## Project Structure

The project is organized into the following main directories:

*   `ASSM/`: Contains assembly language files. These might be examples of code generated by Helium or test cases.
*   `CodeGen/`: Houses the components responsible for generating final target code from an intermediate representation or directly from the parse tree.
*   `InterMedCode/`: Likely contains the logic for generating and managing an intermediate code representation (e.g., three-address code) before final code generation.
*   `LDefs/`: May contain language definitions, such as operator specifications, keywords, or other lexical/grammatical rules for the language Helium compiles.
*   `Lexer/`: Includes the lexical analyzer (lexer or scanner) which breaks down the source code into a stream of tokens. This is often built using tools like Flex.
*   `Parser/`: Contains the syntax analyzer (parser) which takes the token stream from the lexer and builds a parse tree or an abstract syntax tree (AST) according to the language's grammar. This might use tools like Bison or Yacc.
*   `SymbolTable/`: Implements the symbol table, a data structure used to store information about identifiers (variables, functions, etc.) encountered in the source code.

## Building and Running

This section describes how to build and run the Helium compiler.

### Prerequisites

Before you begin, ensure you have the following installed on your system:
*   `g++` (GNU C++ Compiler)
*   `flex` (Fast Lexical Analyzer Generator)
*   `bison` (GNU Parser Generator)

You can typically install these using your system's package manager (e.g., `apt-get install build-essential flex bison` on Debian/Ubuntu).

### Building the Compiler

To build the Helium compiler, navigate to the root directory of the project in your terminal and run the `make` command:

```bash
make
```
This will compile the source files and create an executable named `COMPILER` in the root directory.

### Running the Compiler

Once the compiler is built, you can run it using the following command:

```bash
./COMPILER <input_file>
```
Replace `<input_file>` with the path to the source code file you want to compile.

For a quick test, the project includes a sample test file. You can build and run Helium with this test file using:

```bash
make run
```
This command will first build the compiler (if not already built) and then execute it with `Helium_TEST_CODE` as the input.

### Cleaning Up

To remove the compiled executable and any intermediate object files, you can run:
```bash
make clean
```

## Dependencies

The Helium compiler relies on the following external tools and libraries:

*   **GNU C++ Compiler (`g++`):** Used for compiling the C++ source code.
*   **Flex (Fast Lexical Analyzer Generator):** Used for generating the lexical analyzer from `Lexer/lexfile.l`.
*   **Bison (GNU Parser Generator):** Used for generating the parser from `Parser/grammer.y`.

Ensure these are installed on your system before attempting to build the compiler. Installation instructions are typically found in their respective documentation or can often be handled by your system's package manager (e.g., `sudo apt-get install build-essential flex bison` on Debian/Ubuntu based systems).

## Usage Examples

This section provides a basic example of code that can be compiled by Helium.

### Sample Code

Helium processes a C-like syntax. Here is an example of a simple program that can be saved in a file (e.g., `example.heli`):

```c
int main()
{
    int a;
    int b;

    a = 12 + 34;
    a = a + 1000;
    b = a + 1234;

    return 0;
}
```

The project includes a test file named `Helium_TEST_CODE` with similar content.

### Compiling and Running

1.  **Save the code:** Save the code above into a file, for example, `my_program.heli`.
2.  **Build the compiler:** If you haven't already, build the compiler:
    ```bash
    make
    ```
3.  **Run the compiler:** Execute the compiler with your source file:
    ```bash
    ./COMPILER my_program.heli
    ```

Alternatively, to compile and run the provided test file (`Helium_TEST_CODE`):
```bash
make run
```
This will build the compiler and then process `Helium_TEST_CODE`. The exact output or behavior (e.g., generated assembly, execution result) will depend on the compiler's implementation details.

## Contribution Guidelines

Since Helium is primarily a personal project for studying compiler architecture, contributions are not the main focus. However, if you have suggestions, find bugs, or want to discuss improvements:

1.  **Open an Issue:** Please open an issue on the project's repository to discuss any proposed changes or to report bugs.
2.  **Clarity:** Provide a clear and detailed explanation of the issue or suggestion.

This helps keep track of discussions and potential areas for development.

## License

The licensing information for this project is yet to be determined. Please choose an appropriate open-source license if you plan to share this project publicly.

For example, you could add a `LICENSE` file to your repository with the text of a chosen license (e.g., MIT License, Apache License 2.0) and then update this section to refer to it:

`This project is licensed under the MIT License - see the LICENSE.md file for details.`

## Contact/Author Information

This project was developed as a personal study initiative.

If you have questions or wish to discuss the project, please open an issue on the project's repository.
